module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateComment {
  count: Int!
}

type AggregateLike {
  count: Int!
}

type AggregateProject {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: ID!
  user: User!
  text: String!
  project: Project!
  createdAt: DateTime!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  user: UserCreateOneInput!
  text: String!
  project: ProjectCreateOneWithoutCommentsInput!
}

input CommentCreateManyWithoutProjectInput {
  create: [CommentCreateWithoutProjectInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutProjectInput {
  id: ID
  user: UserCreateOneInput!
  text: String!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
}

type CommentPreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  user: UserUpdateOneRequiredInput
  text: String
  project: ProjectUpdateOneRequiredWithoutCommentsInput
}

input CommentUpdateManyDataInput {
  text: String
}

input CommentUpdateManyMutationInput {
  text: String
}

input CommentUpdateManyWithoutProjectInput {
  create: [CommentCreateWithoutProjectInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutProjectDataInput {
  user: UserUpdateOneRequiredInput
  text: String
}

input CommentUpdateWithWhereUniqueWithoutProjectInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutProjectDataInput!
}

input CommentUpsertWithWhereUniqueWithoutProjectInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutProjectDataInput!
  create: CommentCreateWithoutProjectInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  project: ProjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type Like {
  id: ID!
  project: Project!
  user: User!
}

type LikeConnection {
  pageInfo: PageInfo!
  edges: [LikeEdge]!
  aggregate: AggregateLike!
}

input LikeCreateInput {
  id: ID
  project: ProjectCreateOneWithoutLikesInput!
  user: UserCreateOneInput!
}

input LikeCreateManyWithoutProjectInput {
  create: [LikeCreateWithoutProjectInput!]
  connect: [LikeWhereUniqueInput!]
}

input LikeCreateWithoutProjectInput {
  id: ID
  user: UserCreateOneInput!
}

type LikeEdge {
  node: Like!
  cursor: String!
}

enum LikeOrderByInput {
  id_ASC
  id_DESC
}

type LikePreviousValues {
  id: ID!
}

input LikeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [LikeScalarWhereInput!]
  OR: [LikeScalarWhereInput!]
  NOT: [LikeScalarWhereInput!]
}

type LikeSubscriptionPayload {
  mutation: MutationType!
  node: Like
  updatedFields: [String!]
  previousValues: LikePreviousValues
}

input LikeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LikeWhereInput
  AND: [LikeSubscriptionWhereInput!]
  OR: [LikeSubscriptionWhereInput!]
  NOT: [LikeSubscriptionWhereInput!]
}

input LikeUpdateInput {
  project: ProjectUpdateOneRequiredWithoutLikesInput
  user: UserUpdateOneRequiredInput
}

input LikeUpdateManyWithoutProjectInput {
  create: [LikeCreateWithoutProjectInput!]
  delete: [LikeWhereUniqueInput!]
  connect: [LikeWhereUniqueInput!]
  set: [LikeWhereUniqueInput!]
  disconnect: [LikeWhereUniqueInput!]
  update: [LikeUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [LikeUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [LikeScalarWhereInput!]
}

input LikeUpdateWithoutProjectDataInput {
  user: UserUpdateOneRequiredInput
}

input LikeUpdateWithWhereUniqueWithoutProjectInput {
  where: LikeWhereUniqueInput!
  data: LikeUpdateWithoutProjectDataInput!
}

input LikeUpsertWithWhereUniqueWithoutProjectInput {
  where: LikeWhereUniqueInput!
  update: LikeUpdateWithoutProjectDataInput!
  create: LikeCreateWithoutProjectInput!
}

input LikeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  project: ProjectWhereInput
  user: UserWhereInput
  AND: [LikeWhereInput!]
  OR: [LikeWhereInput!]
  NOT: [LikeWhereInput!]
}

input LikeWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createLike(data: LikeCreateInput!): Like!
  updateLike(data: LikeUpdateInput!, where: LikeWhereUniqueInput!): Like
  upsertLike(where: LikeWhereUniqueInput!, create: LikeCreateInput!, update: LikeUpdateInput!): Like!
  deleteLike(where: LikeWhereUniqueInput!): Like
  deleteManyLikes(where: LikeWhereInput): BatchPayload!
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Project {
  id: ID!
  name: String!
  private: Boolean!
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  createdAt: DateTime!
  lastUpdated: DateTime!
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  id: ID
  name: String!
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  likes: LikeCreateManyWithoutProjectInput
  comments: CommentCreateManyWithoutProjectInput
}

input ProjectCreateManyInput {
  create: [ProjectCreateInput!]
  connect: [ProjectWhereUniqueInput!]
}

input ProjectCreateOneWithoutCommentsInput {
  create: ProjectCreateWithoutCommentsInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateOneWithoutLikesInput {
  create: ProjectCreateWithoutLikesInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutCommentsInput {
  id: ID
  name: String!
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  likes: LikeCreateManyWithoutProjectInput
}

input ProjectCreateWithoutLikesInput {
  id: ID
  name: String!
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  comments: CommentCreateManyWithoutProjectInput
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  private_ASC
  private_DESC
  status_ASC
  status_DESC
  wantFeedback_ASC
  wantFeedback_DESC
  wantAssistance_ASC
  wantAssistance_DESC
  deploymentURL_ASC
  deploymentURL_DESC
  frontEndRepoURL_ASC
  frontEndRepoURL_DESC
  backEndRepoURL_ASC
  backEndRepoURL_DESC
  createdAt_ASC
  createdAt_DESC
  lastUpdated_ASC
  lastUpdated_DESC
}

type ProjectPreviousValues {
  id: ID!
  name: String!
  private: Boolean!
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  createdAt: DateTime!
  lastUpdated: DateTime!
}

input ProjectScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  private: Boolean
  private_not: Boolean
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  wantFeedback: Boolean
  wantFeedback_not: Boolean
  wantAssistance: Boolean
  wantAssistance_not: Boolean
  deploymentURL: String
  deploymentURL_not: String
  deploymentURL_in: [String!]
  deploymentURL_not_in: [String!]
  deploymentURL_lt: String
  deploymentURL_lte: String
  deploymentURL_gt: String
  deploymentURL_gte: String
  deploymentURL_contains: String
  deploymentURL_not_contains: String
  deploymentURL_starts_with: String
  deploymentURL_not_starts_with: String
  deploymentURL_ends_with: String
  deploymentURL_not_ends_with: String
  frontEndRepoURL: String
  frontEndRepoURL_not: String
  frontEndRepoURL_in: [String!]
  frontEndRepoURL_not_in: [String!]
  frontEndRepoURL_lt: String
  frontEndRepoURL_lte: String
  frontEndRepoURL_gt: String
  frontEndRepoURL_gte: String
  frontEndRepoURL_contains: String
  frontEndRepoURL_not_contains: String
  frontEndRepoURL_starts_with: String
  frontEndRepoURL_not_starts_with: String
  frontEndRepoURL_ends_with: String
  frontEndRepoURL_not_ends_with: String
  backEndRepoURL: String
  backEndRepoURL_not: String
  backEndRepoURL_in: [String!]
  backEndRepoURL_not_in: [String!]
  backEndRepoURL_lt: String
  backEndRepoURL_lte: String
  backEndRepoURL_gt: String
  backEndRepoURL_gte: String
  backEndRepoURL_contains: String
  backEndRepoURL_not_contains: String
  backEndRepoURL_starts_with: String
  backEndRepoURL_not_starts_with: String
  backEndRepoURL_ends_with: String
  backEndRepoURL_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  lastUpdated: DateTime
  lastUpdated_not: DateTime
  lastUpdated_in: [DateTime!]
  lastUpdated_not_in: [DateTime!]
  lastUpdated_lt: DateTime
  lastUpdated_lte: DateTime
  lastUpdated_gt: DateTime
  lastUpdated_gte: DateTime
  AND: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateDataInput {
  name: String
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  likes: LikeUpdateManyWithoutProjectInput
  comments: CommentUpdateManyWithoutProjectInput
}

input ProjectUpdateInput {
  name: String
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  likes: LikeUpdateManyWithoutProjectInput
  comments: CommentUpdateManyWithoutProjectInput
}

input ProjectUpdateManyDataInput {
  name: String
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
}

input ProjectUpdateManyInput {
  create: [ProjectCreateInput!]
  update: [ProjectUpdateWithWhereUniqueNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueNestedInput!]
  delete: [ProjectWhereUniqueInput!]
  connect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  disconnect: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
}

input ProjectUpdateManyMutationInput {
  name: String
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
}

input ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput!
  data: ProjectUpdateManyDataInput!
}

input ProjectUpdateOneRequiredWithoutCommentsInput {
  create: ProjectCreateWithoutCommentsInput
  update: ProjectUpdateWithoutCommentsDataInput
  upsert: ProjectUpsertWithoutCommentsInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateOneRequiredWithoutLikesInput {
  create: ProjectCreateWithoutLikesInput
  update: ProjectUpdateWithoutLikesDataInput
  upsert: ProjectUpsertWithoutLikesInput
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutCommentsDataInput {
  name: String
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  likes: LikeUpdateManyWithoutProjectInput
}

input ProjectUpdateWithoutLikesDataInput {
  name: String
  private: Boolean
  status: String
  wantFeedback: Boolean
  wantAssistance: Boolean
  deploymentURL: String
  frontEndRepoURL: String
  backEndRepoURL: String
  comments: CommentUpdateManyWithoutProjectInput
}

input ProjectUpdateWithWhereUniqueNestedInput {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateDataInput!
}

input ProjectUpsertWithoutCommentsInput {
  update: ProjectUpdateWithoutCommentsDataInput!
  create: ProjectCreateWithoutCommentsInput!
}

input ProjectUpsertWithoutLikesInput {
  update: ProjectUpdateWithoutLikesDataInput!
  create: ProjectCreateWithoutLikesInput!
}

input ProjectUpsertWithWhereUniqueNestedInput {
  where: ProjectWhereUniqueInput!
  update: ProjectUpdateDataInput!
  create: ProjectCreateInput!
}

input ProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  private: Boolean
  private_not: Boolean
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  wantFeedback: Boolean
  wantFeedback_not: Boolean
  wantAssistance: Boolean
  wantAssistance_not: Boolean
  deploymentURL: String
  deploymentURL_not: String
  deploymentURL_in: [String!]
  deploymentURL_not_in: [String!]
  deploymentURL_lt: String
  deploymentURL_lte: String
  deploymentURL_gt: String
  deploymentURL_gte: String
  deploymentURL_contains: String
  deploymentURL_not_contains: String
  deploymentURL_starts_with: String
  deploymentURL_not_starts_with: String
  deploymentURL_ends_with: String
  deploymentURL_not_ends_with: String
  frontEndRepoURL: String
  frontEndRepoURL_not: String
  frontEndRepoURL_in: [String!]
  frontEndRepoURL_not_in: [String!]
  frontEndRepoURL_lt: String
  frontEndRepoURL_lte: String
  frontEndRepoURL_gt: String
  frontEndRepoURL_gte: String
  frontEndRepoURL_contains: String
  frontEndRepoURL_not_contains: String
  frontEndRepoURL_starts_with: String
  frontEndRepoURL_not_starts_with: String
  frontEndRepoURL_ends_with: String
  frontEndRepoURL_not_ends_with: String
  backEndRepoURL: String
  backEndRepoURL_not: String
  backEndRepoURL_in: [String!]
  backEndRepoURL_not_in: [String!]
  backEndRepoURL_lt: String
  backEndRepoURL_lte: String
  backEndRepoURL_gt: String
  backEndRepoURL_gte: String
  backEndRepoURL_contains: String
  backEndRepoURL_not_contains: String
  backEndRepoURL_starts_with: String
  backEndRepoURL_not_starts_with: String
  backEndRepoURL_ends_with: String
  backEndRepoURL_not_ends_with: String
  likes_every: LikeWhereInput
  likes_some: LikeWhereInput
  likes_none: LikeWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  lastUpdated: DateTime
  lastUpdated_not: DateTime
  lastUpdated_in: [DateTime!]
  lastUpdated_not_in: [DateTime!]
  lastUpdated_lt: DateTime
  lastUpdated_lte: DateTime
  lastUpdated_gt: DateTime
  lastUpdated_gte: DateTime
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: ID
}

type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  like(where: LikeWhereUniqueInput!): Like
  likes(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Like]!
  likesConnection(where: LikeWhereInput, orderBy: LikeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LikeConnection!
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  like(where: LikeSubscriptionWhereInput): LikeSubscriptionPayload
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  username: String!
  password: String!
  name: String
  bio: String
  techStack: String
  avatarURL: String
  githubURL: String
  linkedinURL: String
  portfolioURL: String
  twitterURL: String
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project!]
  createdAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  username: String!
  password: String!
  name: String
  bio: String
  techStack: String
  avatarURL: String
  githubURL: String
  linkedinURL: String
  portfolioURL: String
  twitterURL: String
  projects: ProjectCreateManyInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  bio_ASC
  bio_DESC
  techStack_ASC
  techStack_DESC
  avatarURL_ASC
  avatarURL_DESC
  githubURL_ASC
  githubURL_DESC
  linkedinURL_ASC
  linkedinURL_DESC
  portfolioURL_ASC
  portfolioURL_DESC
  twitterURL_ASC
  twitterURL_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  username: String!
  password: String!
  name: String
  bio: String
  techStack: String
  avatarURL: String
  githubURL: String
  linkedinURL: String
  portfolioURL: String
  twitterURL: String
  createdAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  username: String
  password: String
  name: String
  bio: String
  techStack: String
  avatarURL: String
  githubURL: String
  linkedinURL: String
  portfolioURL: String
  twitterURL: String
  projects: ProjectUpdateManyInput
}

input UserUpdateInput {
  username: String
  password: String
  name: String
  bio: String
  techStack: String
  avatarURL: String
  githubURL: String
  linkedinURL: String
  portfolioURL: String
  twitterURL: String
  projects: ProjectUpdateManyInput
}

input UserUpdateManyMutationInput {
  username: String
  password: String
  name: String
  bio: String
  techStack: String
  avatarURL: String
  githubURL: String
  linkedinURL: String
  portfolioURL: String
  twitterURL: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  techStack: String
  techStack_not: String
  techStack_in: [String!]
  techStack_not_in: [String!]
  techStack_lt: String
  techStack_lte: String
  techStack_gt: String
  techStack_gte: String
  techStack_contains: String
  techStack_not_contains: String
  techStack_starts_with: String
  techStack_not_starts_with: String
  techStack_ends_with: String
  techStack_not_ends_with: String
  avatarURL: String
  avatarURL_not: String
  avatarURL_in: [String!]
  avatarURL_not_in: [String!]
  avatarURL_lt: String
  avatarURL_lte: String
  avatarURL_gt: String
  avatarURL_gte: String
  avatarURL_contains: String
  avatarURL_not_contains: String
  avatarURL_starts_with: String
  avatarURL_not_starts_with: String
  avatarURL_ends_with: String
  avatarURL_not_ends_with: String
  githubURL: String
  githubURL_not: String
  githubURL_in: [String!]
  githubURL_not_in: [String!]
  githubURL_lt: String
  githubURL_lte: String
  githubURL_gt: String
  githubURL_gte: String
  githubURL_contains: String
  githubURL_not_contains: String
  githubURL_starts_with: String
  githubURL_not_starts_with: String
  githubURL_ends_with: String
  githubURL_not_ends_with: String
  linkedinURL: String
  linkedinURL_not: String
  linkedinURL_in: [String!]
  linkedinURL_not_in: [String!]
  linkedinURL_lt: String
  linkedinURL_lte: String
  linkedinURL_gt: String
  linkedinURL_gte: String
  linkedinURL_contains: String
  linkedinURL_not_contains: String
  linkedinURL_starts_with: String
  linkedinURL_not_starts_with: String
  linkedinURL_ends_with: String
  linkedinURL_not_ends_with: String
  portfolioURL: String
  portfolioURL_not: String
  portfolioURL_in: [String!]
  portfolioURL_not_in: [String!]
  portfolioURL_lt: String
  portfolioURL_lte: String
  portfolioURL_gt: String
  portfolioURL_gte: String
  portfolioURL_contains: String
  portfolioURL_not_contains: String
  portfolioURL_starts_with: String
  portfolioURL_not_starts_with: String
  portfolioURL_ends_with: String
  portfolioURL_not_ends_with: String
  twitterURL: String
  twitterURL_not: String
  twitterURL_in: [String!]
  twitterURL_not_in: [String!]
  twitterURL_lt: String
  twitterURL_lte: String
  twitterURL_gt: String
  twitterURL_gte: String
  twitterURL_contains: String
  twitterURL_not_contains: String
  twitterURL_starts_with: String
  twitterURL_not_starts_with: String
  twitterURL_ends_with: String
  twitterURL_not_ends_with: String
  projects_every: ProjectWhereInput
  projects_some: ProjectWhereInput
  projects_none: ProjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    